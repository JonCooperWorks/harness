# CVE-2025-54068 Exploit Plugin

A harness plugin that exploits CVE-2025-54068, a critical vulnerability in Livewire (Laravel full-stack framework) affecting versions up to and including v3.6.3. This vulnerability allows unauthenticated attackers to execute remote commands by exploiting component property hydration through PHP deserialization.

## Building

```bash
cargo build --target wasm32-wasip1 --release
```

The compiled WASM will be at: `target/wasm32-wasip1/release/cve_2025_54068_plugin.wasm`

## Encrypting, Signing, and Running

### Option 1: Direct Encryption

```bash
# First, encrypt the plugin (Exploit Owner)
./bin/encrypt \
  -plugin examples/cve-2025-54068/target/wasm32-wasip1/release/cve_2025_54068_plugin.wasm \
  -type wasm \
  -harness-key harness_public.pem \
  -target-key target_public.pem \
  -exploit-keystore-key "exploit-key" \
  -output examples/cve-2025-54068/cve-2025-54068.encrypted

# Then, sign with execution arguments (Target)
./bin/sign \
  -file examples/cve-2025-54068/cve-2025-54068.encrypted \
  -target-keystore-key "target-key" \
  -exploit-key exploit_public.pem \
  -harness-key harness_public.pem \
  -args '{"url":"http://localhost:9040","command":"id"}' \
  -output examples/cve-2025-54068/cve-2025-54068.approved

# Finally, execute the plugin (Harness)
./bin/harness \
  -file examples/cve-2025-54068/cve-2025-54068.approved \
  -harness-keystore-key "harness-key" \
  -target-key target_public.pem \
  -exploit-key exploit_public.pem
```

### Option 2: Store First, Then Encrypt

```bash
# First, store the plugin (Exploit Owner) - encrypts to your own key
./bin/store \
  -plugin examples/cve-2025-54068/target/wasm32-wasip1/release/cve_2025_54068_plugin.wasm \
  -type wasm \
  -harness-key harness_public.pem \
  -exploit-keystore-key "exploit-key" \
  -output examples/cve-2025-54068/cve-2025-54068.wasm.stored

# Later, encrypt from stored file (Exploit Owner)
./bin/encrypt \
  -plugin examples/cve-2025-54068/cve-2025-54068.wasm.stored \
  -type wasm \
  -harness-key harness_public.pem \
  -target-key target_public.pem \
  -exploit-keystore-key "exploit-key" \
  -output examples/cve-2025-54068/cve-2025-54068.encrypted

# Then, sign with execution arguments (Target)
./bin/sign \
  -file examples/cve-2025-54068/cve-2025-54068.encrypted \
  -target-keystore-key "target-key" \
  -exploit-key exploit_public.pem \
  -harness-key harness_public.pem \
  -args '{"url":"http://localhost:9040","command":"id"}' \
  -output examples/cve-2025-54068/cve-2025-54068.approved

# Finally, execute the plugin (Harness)
./bin/harness \
  -file examples/cve-2025-54068/cve-2025-54068.approved \
  -harness-keystore-key "harness-key" \
  -target-key target_public.pem \
  -exploit-key exploit_public.pem
```

## Plugin Storage

The harness system makes no assumptions about how you store your exploit plugins. You can use any storage infrastructure you prefer (S3, databases, file systems, etc.). The system is designed to be compatible with existing infrastructure.

If you don't have storage infrastructure set up, the `store` command provides an easy option that works within the existing cryptosystem:

- **Stored files** (`.stored` extension) are encrypted to the exploit owner's key, giving you full control
- Only you (the exploit owner) can decrypt stored files using your `exploit-keystore-key`
- The `encrypt` command automatically detects stored files and can re-encrypt them for targets
- Stored files use the same encryption format as regular encrypted files, just encrypted to your key instead of the target's key

The `store` command is optional - you can use any storage mechanism you prefer. The `encrypt` command accepts both raw plugin binaries and stored files transparently.

## Arguments

- `url` (required, string): Target URL of the Livewire application
- `command` (optional, string): Command to execute (default: `id`). Can be just the command like `id` or `whoami`, or in function format like `system('id')`
- `headers` (optional, array): Additional headers to add to the request (format: `["Header-Name: value"]`)
- `app_key` (optional, string): APP_KEY to sign snapshot (enables exploit with APP_KEY). Can be base64 encoded (format: `base64:...`) or raw key
- `debug` (optional, boolean): Enable debug output (default: `false`)
- `force` (optional, boolean): Force exploit even if version does not seem vulnerable (default: `false`)
- `check` (optional, boolean): Only check if the remote target is vulnerable (only relevant for exploit without APP_KEY, default: `false`)

### Example: Exploit with APP_KEY

```bash
-args '{"url":"http://example.com","app_key":"base64:your-app-key-here","command":"id"}'
```

### Example: Exploit without APP_KEY (Check Mode)

```bash
-args '{"url":"http://example.com","check":true}'
```

### Example: Exploit without APP_KEY (Execute Command)

```bash
-args '{"url":"http://example.com","command":"whoami"}'
```

### Example: With Custom Headers

```bash
-args '{"url":"http://example.com","headers":["X-Custom-Header: value","Authorization: Bearer token"],"command":"id"}'
```

## How It Works

This plugin exploits CVE-2025-54068, a critical vulnerability in Livewire that allows unauthenticated remote command execution by exploiting component property hydration through PHP object deserialization:

### Exploit Flow

1. **Page Fetch**: The plugin first fetches the target page to extract Livewire snapshots embedded in the HTML
2. **Snapshot Extraction**: Uses regex to find `wire:snapshot="..."` attributes in the page HTML
3. **CSRF Token Extraction**: Extracts CSRF token from the page (from `data-csrf`, `livewireScriptConfig`, or meta tags)
4. **Update URI Detection**: Determines the Livewire update endpoint (defaults to `/livewire/update` or extracts from page)
5. **Version Check**: Checks Livewire version by matching version hashes in the page content against known vulnerable versions (< v3.6.4)

### Exploit Without APP_KEY

The exploit uses a two-stage approach:

1. **Stage 1 - Cast Parameter as Array**: 
   - Sends a payload to cast a component parameter as an array
   - Receives a new snapshot from the server with the parameter type changed

2. **Stage 2 - Send RCE Payload**:
   - Uses the modified snapshot to send a PHP deserialization payload
   - The payload exploits Laravel's internal classes:
     - `Illuminate\Broadcasting\BroadcastEvent`
     - `Illuminate\Validation\Validator`
     - `Laravel\SerializableClosure\Serializers\Signed`
     - `GuzzleHttp\Psr7\FnStream`
   - Triggers command execution through the deserialization chain

The exploit:
- First tries to find object-type parameters in snapshots (avoids bruteforce)
- If no object-type params found, bruteforces all parameters in the snapshot
- Tries each snapshot found in the page until one succeeds

### Exploit With APP_KEY

When APP_KEY is provided:

1. **Key Parsing**: Parses the APP_KEY (supports `base64:...` format or raw base64 string)
2. **Payload Building**: 
   - Modifies the snapshot's first parameter with the PHP deserialization payload
   - Calculates a new checksum using HMAC-SHA256 on the modified snapshot
   - Removes spaces and escapes slashes before checksumming (Laravel's format)
3. **Send Signed Payload**: Sends the signed snapshot to the update endpoint
   - The signature authenticates the request, bypassing some security checks

### PHP Deserialization Payload

The exploit uses a carefully crafted PHP object deserialization payload that chains together Laravel internal classes to achieve remote command execution. The payload structure is embedded from the Livepyre `payload.json` template, with placeholders replaced dynamically:

- `[FUNCTION_LEN]` - Length of the function name (e.g., "system")
- `[FUNCTION]` - Function name to execute
- `[PARAM_LEN]` - Length of the command parameter
- `[PARAM]` - Command parameter (e.g., "id")

## Security Note

This plugin is for authorized security testing only. Use only on systems you own or have explicit permission to test. CVE-2025-54068 affects Livewire versions up to and including v3.6.3. Users should upgrade to Livewire v3.6.4 or later to mitigate this vulnerability.
